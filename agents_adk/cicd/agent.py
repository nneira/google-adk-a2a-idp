#!/usr/bin/env python3
"""
CI/CD AGENT - ADK Interactive Mode
===================================

Genera scripts de CI/CD de forma conversacional.
Crea build.sh, test.sh, deploy.sh basados en la configuraci√≥n de plataforma.

Author: Nicol√°s Neira
Web: https://nicolasneira.com
YouTube: https://www.youtube.com/@NicolasNeiraGarcia?sub_confirmation=1
Email: hola@nicolasneira.com
Date: 2026-01-18 (ADK Version)
"""

import os
import json
import yaml
from pathlib import Path
from datetime import datetime
from google.adk.agents.llm_agent import Agent

OUTPUT_DIR = os.getenv('ADK_OUTPUT_DIR', '/app/outputs')


def get_infrastructure_decisions() -> dict:
    """
    Lee las decisiones de infraestructura guardadas por Infrastructure Agent.

    Returns:
        dict: Informaci√≥n sobre servicios generados incluyendo CI/CD runner
    """
    json_path = Path(OUTPUT_DIR) / "infrastructure-decisions.json"

    if not json_path.exists():
        return {
            "error": "Infrastructure decisions no encontrado. Infrastructure Agent debe ejecutarse primero."
        }

    with open(json_path, 'r') as f:
        decisions = json.load(f)

    return {
        "status": "success",
        "decisions": decisions,
        "cicd_provider": decisions.get('ci_cd_runner', {}).get('provider'),
        "cicd_service": decisions.get('ci_cd_runner', {}).get('runner_service'),
        "cicd_available": decisions.get('ci_cd_runner', {}).get('available', False),
        "cicd_image": decisions.get('ci_cd_runner', {}).get('runner_image'),
        "has_web_ui": decisions.get('ci_cd_runner', {}).get('has_web_ui', False),
        "ui_url": decisions.get('ci_cd_runner', {}).get('ui_url'),
        "docker_compose_path": decisions.get('files_generated', {}).get('docker_compose_absolute')
    }


def configure_jenkins_job() -> dict:
    """
    Configura autom√°ticamente el pipeline job en Jenkins.
    Crea el config.xml y lo copia al volumen de Jenkins.

    Returns:
        dict: Status de la configuraci√≥n
    """
    # Config XML del pipeline job
    job_config_xml = """<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1385.vb_58b_86ea_fff1">
  <description>IDP CI/CD Pipeline - Auto-generated by AI Agents</description>
  <keepDependencies>false</keepDependencies>
  <properties/>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@3839.v91d0d6e_aa_a_9">
    <script>
pipeline {
    agent any

    environment {
        COMPOSE_PROJECT_NAME = 'idp'
        OUTPUTS_DIR = '/var/jenkins_home/workspace/IDP-Pipeline'
    }

    stages {
        stage('Build') {
            steps {
                echo 'üî® Building application...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/build.sh &amp;&amp; ./cicd/build.sh || echo "Build completed with warnings"'
                }
            }
        }

        stage('Test') {
            steps {
                echo 'üß™ Running tests...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/test.sh &amp;&amp; ./cicd/test.sh || echo "Tests completed with warnings"'
                }
            }
        }

        stage('Deploy') {
            steps {
                echo 'üöÄ Deploying application...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/deploy.sh &amp;&amp; ./cicd/deploy.sh || echo "Deploy completed with warnings"'
                }
            }
        }
    }

    post {
        always {
            echo 'üìä Pipeline completed'
        }
        success {
            echo '‚úÖ Pipeline succeeded!'
        }
        failure {
            echo '‚ùå Pipeline failed!'
        }
    }
}
    </script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
"""

    # Directorio del job en Jenkins
    job_name = "IDP-Pipeline"
    jenkins_jobs_dir = Path(OUTPUT_DIR) / "jenkins_home" / "jobs" / job_name
    jenkins_jobs_dir.mkdir(parents=True, exist_ok=True)

    # Guardar config.xml
    config_path = jenkins_jobs_dir / "config.xml"
    with open(config_path, 'w') as f:
        f.write(job_config_xml)

    # TAMBI√âN guardarlo en cicd/ para que setup-jenkins.sh lo encuentre
    cicd_dir = Path(OUTPUT_DIR) / "cicd"
    cicd_dir.mkdir(parents=True, exist_ok=True)
    cicd_job_path = cicd_dir / "jenkins-job.xml"
    with open(cicd_job_path, 'w') as f:
        f.write(job_config_xml)

    return {
        "status": "success",
        "job_name": job_name,
        "config_path": str(config_path),
        "cicd_job_path": str(cicd_job_path),
        "instructions": f"Job '{job_name}' configurado. Jenkins lo detectar√° al reiniciar o hacer reload."
    }


def generate_jenkinsfile() -> dict:
    """
    Genera Jenkinsfile para Jenkins CI/CD.

    Returns:
        dict: Status y path del archivo generado
    """
    jenkinsfile_content = """pipeline {
    agent any

    environment {
        COMPOSE_PROJECT_NAME = 'idp'
        OUTPUTS_DIR = '/var/jenkins_home/workspace/IDP-Pipeline'
    }

    stages {
        stage('Build') {
            steps {
                echo 'üî® Building application...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/build.sh && ./cicd/build.sh || echo "Build completed with warnings"'
                }
            }
        }

        stage('Test') {
            steps {
                echo 'üß™ Running tests...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/test.sh && ./cicd/test.sh || echo "Tests completed with warnings"'
                }
            }
        }

        stage('Deploy') {
            steps {
                echo 'üöÄ Deploying application...'
                dir("${OUTPUTS_DIR}") {
                    sh 'chmod +x cicd/deploy.sh && ./cicd/deploy.sh || echo "Deploy completed with warnings"'
                }
            }
        }
    }

    post {
        always {
            echo 'üìä Pipeline completed'
        }
        success {
            echo '‚úÖ Pipeline succeeded!'
        }
        failure {
            echo '‚ùå Pipeline failed!'
        }
    }
}
"""

    # Guardar Jenkinsfile
    jenkinsfile_path = Path(OUTPUT_DIR) / "Jenkinsfile"
    with open(jenkinsfile_path, 'w') as f:
        f.write(jenkinsfile_content)

    return {
        "status": "success",
        "provider": "Jenkins",
        "file_path": str(jenkinsfile_path),
        "file_name": "Jenkinsfile",
        "has_web_ui": True,
        "ui_url": "http://localhost:8080",
        "instructions": "Jenkinsfile generated. Access Jenkins UI at http://localhost:8080 to configure and run the pipeline."
    }


def generate_github_actions_workflow() -> dict:
    """
    Genera workflow de GitHub Actions.

    Returns:
        dict: Status y path del archivo generado
    """
    workflow_content = """name: IDP CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build application
        run: |
          echo "üî® Building application..."
          docker-compose -f docker-compose/app-stack.yml build

      - name: Run tests
        run: |
          echo "üß™ Running tests..."
          docker-compose -f docker-compose/app-stack.yml up -d database cache
          sleep 5
          docker-compose -f docker-compose/app-stack.yml run --rm app pytest tests/ -v || true

      - name: Security scan
        run: |
          echo "üîí Running security scan..."
          docker-compose -f docker-compose/app-stack.yml run --rm security-scanner filesystem --format json /scan || true

      - name: Deploy
        if: github.ref == 'refs/heads/main'
        run: |
          echo "üöÄ Deploying application..."
          docker-compose -f docker-compose/app-stack.yml up -d
          docker-compose -f docker-compose/app-stack.yml ps
"""

    # Crear directorio .github/workflows
    workflows_dir = Path(OUTPUT_DIR) / ".github" / "workflows"
    workflows_dir.mkdir(parents=True, exist_ok=True)

    # Guardar workflow
    workflow_path = workflows_dir / "ci.yml"
    with open(workflow_path, 'w') as f:
        f.write(workflow_content)

    return {
        "status": "success",
        "provider": "GitHub Actions",
        "file_path": str(workflow_path),
        "file_name": ".github/workflows/ci.yml",
        "has_web_ui": False,
        "execution": "docker compose run ci-runner -W .github/workflows/ci.yml",
        "instructions": "GitHub Actions workflow generated. Push to GitHub to run, or test locally with: docker compose run ci-runner"
    }


def generate_gitlab_ci_config() -> dict:
    """
    Genera configuraci√≥n de GitLab CI.

    Returns:
        dict: Error - no implementado completamente
    """
    return {
        "status": "not_implemented",
        "message": "GitLab CI configuration generation is not fully implemented yet.",
        "provider": "GitLab CI",
        "suggestion": "Try generate_jenkinsfile() or generate_github_actions_workflow() as alternative"
    }


def generate_circleci_config() -> dict:
    """
    Genera configuraci√≥n de CircleCI.

    Returns:
        dict: Error - no implementado completamente
    """
    return {
        "status": "not_implemented",
        "message": "CircleCI configuration generation is not fully implemented yet.",
        "provider": "CircleCI",
        "suggestion": "Try generate_jenkinsfile() or generate_github_actions_workflow() as alternative"
    }


def generate_dummy_app() -> dict:
    """
    Genera una aplicaci√≥n dummy (FastAPI) para demostraci√≥n del pipeline.
    Crea app/main.py, app/Dockerfile, app/requirements.txt y tests/test_app.py.
    
    Returns:
        dict: Status y paths generados
    """
    app_dir = Path(OUTPUT_DIR) / "app"
    app_dir.mkdir(parents=True, exist_ok=True)
    tests_dir = app_dir / "tests"
    tests_dir.mkdir(parents=True, exist_ok=True)
    
    # main.py
    main_py = """\"\"\"
Dummy App - Para demostraci√≥n del pipeline CI/CD
Esta app es generada por el IDP y puede ser buildeada/testeada/deployada por Jenkins.
\"\"\"
from fastapi import FastAPI
from datetime import datetime

app = FastAPI(
    title="IDP Dummy App",
    description="App de demostraci√≥n generada por el IDP",
    version="1.0.0"
)

@app.get("/")
def root():
    \"\"\"Endpoint principal.\"\"\"
    return {
        "message": "Hello from IDP Dummy App!",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat()
    }

@app.get("/health")
def health():
    \"\"\"Health check endpoint.\"\"\"
    return {
        "status": "healthy",
        "service": "dummy-app",
        "version": "1.0.0"
    }

@app.get("/api/users")
def get_users():
    \"\"\"Endpoint dummy de usuarios.\"\"\"
    return {
        "users": [
            {"id": 1, "name": "Alice", "email": "alice@example.com"},
            {"id": 2, "name": "Bob", "email": "bob@example.com"},
            {"id": 3, "name": "Charlie", "email": "charlie@example.com"}
        ],
        "total": 3
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8888)
"""
    with open(app_dir / "main.py", 'w') as f:
        f.write(main_py)
        
    # requirements.txt
    reqs = """fastapi>=0.100.0
uvicorn>=0.23.0
pytest>=7.4.0
httpx>=0.24.0
"""
    with open(app_dir / "requirements.txt", 'w') as f:
        f.write(reqs)
        
    # Dockerfile
    dockerfile = """FROM python:3.11-slim

WORKDIR /app

# Copiar requirements y instalar
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiar c√≥digo
COPY . .

# Puerto de la app (8888)
EXPOSE 8888

# Comando de inicio
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8888"]
"""
    with open(app_dir / "Dockerfile", 'w') as f:
        f.write(dockerfile)
        
    # tests/__init__.py
    with open(tests_dir / "__init__.py", 'w') as f:
        f.write("# Tests package")

    # tests/test_app.py
    test_py = """\"\"\"
Tests para la Dummy App
Estos tests ser√°n ejecutados por el pipeline de Jenkins.
\"\"\"
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import pytest
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_root_endpoint():
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert data["message"] == "Hello from IDP Dummy App!"

def test_health_endpoint():
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"

def test_users_endpoint():
    response = client.get("/api/users")
    assert response.status_code == 200
    data = response.json()
    assert len(data["users"]) == 3
"""
    with open(tests_dir / "test_app.py", 'w') as f:
        f.write(test_py)
        
    return {
        "status": "success",
        "app_dir": str(app_dir),
        "files_generated": ["main.py", "Dockerfile", "requirements.txt", "tests/test_app.py"]
    }


def save_cicd_scripts(cicd_summary: str = "generate_default") -> dict:
    """
    Guarda los scripts de CI/CD generados.

    Args:
        cicd_summary: Resumen en formato:
            "BUILD: [contenido build.sh] | TEST: [contenido test.sh] | DEPLOY: [contenido deploy.sh] | DESCRIPTION: Build->Test->Deploy pipeline"
            O simplemente "generate_default" para generar scripts por defecto.

    Returns:
        dict: Confirmaci√≥n de guardado
    """
    # Leer docker-compose path desde infrastructure-decisions.json
    docker_compose_path = "docker-compose.yml"  # default fallback
    infra_json = Path(OUTPUT_DIR) / "infrastructure-decisions.json"

    if infra_json.exists():
        with open(infra_json, 'r') as f:
            infra_data = json.load(f)
            files_gen = infra_data.get('files_generated', {})
            if 'docker_compose' in files_gen:
                docker_compose_path = files_gen['docker_compose']

    # Si pide default, generar scripts completos
    if cicd_summary == "generate_default" or not cicd_summary or len(cicd_summary) < 50:
        build_script = f"""#!/bin/bash
set -e

# Colors
GREEN='\\033[0;32m'
RED='\\033[0;31m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

echo -e "${{GREEN}}üî® Building IDP Application...${{NC}}"

cd "$(dirname "$0")/.."

# Validate app directory exists
if [ ! -d "app" ]; then
    echo -e "${{RED}}‚ùå app/ directory not found${{NC}}"
    exit 1
fi

# Build Docker image
echo "Building Docker image for dummy-app..."
docker build -t idp-dummy-app:latest app/

echo ""
echo -e "${{GREEN}}‚úÖ Build completed successfully${{NC}}"
echo "   Image: idp-dummy-app:latest"
"""

        test_script = f"""#!/bin/bash
set -e

# Colors
GREEN='\\033[0;32m'
RED='\\033[0;31m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

echo -e "${{GREEN}}üß™ Running Tests...${{NC}}"

cd "$(dirname "$0")/.."

# Run tests inside Docker using the pre-built image
# Not mounting volumes to avoid issues with Docker-in-Docker paths in Jenkins
echo "Running pytest inside container image..."
docker run --rm \\
    idp-dummy-app:latest \\
    pytest tests/ -v --tb=short

echo ""
echo -e "${{GREEN}}‚úÖ All tests passed!${{NC}}"
"""

        deploy_script = f"""#!/bin/bash
set -e

# Colors
GREEN='\\033[0;32m'
RED='\\033[0;31m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

echo -e "${{GREEN}}üöÄ Deploying Application...${{NC}}"

cd "$(dirname "$0")/.."

# Stop existing container if running
echo "Stopping previous deployment..."
docker stop idp-dummy-app 2>/dev/null || true
docker rm idp-dummy-app 2>/dev/null || true

# Deploy new container
# Attached to idp_network so Jenkins can reach it by name
echo "Starting new deployment..."

# Detect network name dynamically (might be prefixed)
NETWORK_NAME=$(docker network ls --format "{{{{.Name}}}}" | grep "idp_network" | head -n 1)
if [ -z "$NETWORK_NAME" ]; then
    echo "‚ö†Ô∏è  Network 'idp_network' not found. Using 'bridge'"
    NETWORK_NAME="bridge"
else
    echo "‚úÖ Found network: $NETWORK_NAME"
fi

docker run -d \\
    --name idp-dummy-app \\
    --network "$NETWORK_NAME" \\
    -p 8888:8888 \\
    idp-dummy-app:latest || echo "Container may already exist"

# Wait for app to be ready
echo -e "${{YELLOW}}‚è≥ Waiting for app to start...${{NC}}"
sleep 5

# Health check
echo "Running health check..."

if curl -sf http://idp-dummy-app:8888/health > /dev/null 2>&1; then
    CACHE_ENDPOINT="http://idp-dummy-app:8888"
elif curl -sf http://localhost:8888/health > /dev/null 2>&1; then
    CACHE_ENDPOINT="http://localhost:8888"
else
    echo -e "${{YELLOW}}‚ö†Ô∏è  Could not reach health endpoint (yet). App might still be starting.${{NC}}"
    echo "Check logs with: docker logs idp-dummy-app"
    # Don't fail the pipeline for health check timeout in demo
    exit 0
fi

echo ""
echo -e "${{GREEN}}‚úÖ Deployment successful!${{NC}}"
echo ""
echo "üåê App running at: http://localhost:8888"
echo "   - Health: $CACHE_ENDPOINT/health"
echo "   - Users: $CACHE_ENDPOINT/api/users"
"""

        description = "Build->Test->Deploy pipeline for IDP"
    else:
        parts = {}
        sections = cicd_summary.split('| ')
        for section in sections:
            if ':' in section:
                key, value = section.split(':', 1)
                parts[key.strip().upper()] = value.strip()

        build_script = parts.get('BUILD', '#!/bin/bash\necho "Build script"\n')
        test_script = parts.get('TEST', '#!/bin/bash\necho "Test script"\n')
        deploy_script = parts.get('DEPLOY', '#!/bin/bash\necho "Deploy script"\n')
        description = parts.get('DESCRIPTION', 'CI/CD Pipeline')

    cicd_dir = Path(OUTPUT_DIR) / "cicd"
    cicd_dir.mkdir(parents=True, exist_ok=True)

    setup_jenkins_script = """#!/bin/bash
set -e

echo "üîß Setting up Jenkins automatically..."

# Wait for Jenkins to be ready
echo "‚è≥ Waiting for Jenkins to start..."
MAX_RETRIES=60
count=0
until docker exec jenkins curl -sf http://localhost:8080/login >/dev/null 2>&1; do
    sleep 2
    count=$((count+1))
    if [ $count -ge $MAX_RETRIES ]; then
        echo "‚ùå Jenkins failed to start in 120 seconds"
        exit 1
    fi
    echo -n "."
done
echo ""
echo "‚úÖ Jenkins is ready!"
sleep 5

# 1. Install Docker CLI (CRITICAL for pipeline)
echo "üê≥ Installing Docker CLI in Jenkins..."
docker exec -u root jenkins bash -c '
if ! command -v docker &> /dev/null; then
    curl -fsSLO https://download.docker.com/linux/static/stable/x86_64/docker-24.0.7.tgz
    tar xzvf docker-24.0.7.tgz > /dev/null
    mv docker/docker /usr/local/bin/
    rm -rf docker docker-24.0.7.tgz
    chmod +x /usr/local/bin/docker
    echo "‚úÖ Docker CLI installed"
else
    echo "‚úÖ Docker CLI already installed"
fi
'

# 2. Install docker-compose
echo "üì¶ Installing docker-compose in Jenkins..."
docker exec -u root jenkins sh -c "curl -sL https://github.com/docker/compose/releases/download/v2.32.3/docker-compose-linux-\$(uname -m) -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose"

# 3. Install workflow plugins
echo "üì¶ Installing Jenkins workflow plugins..."
docker exec jenkins jenkins-plugin-cli --plugins workflow-aggregator:latest git

# 4. Copy IDP-Pipeline job if exists
if [ -f "cicd/jenkins-job.xml" ]; then
    echo "üìã Creating IDP-Pipeline job..."
    docker cp cicd/jenkins-job.xml jenkins:/tmp/config.xml
    docker exec jenkins sh -c "mkdir -p /var/jenkins_home/jobs/IDP-Pipeline && cp /tmp/config.xml /var/jenkins_home/jobs/IDP-Pipeline/config.xml && chown -R jenkins:jenkins /var/jenkins_home/jobs/IDP-Pipeline"
    echo "‚úÖ Job created"
fi

# 5. Restart Jenkins to apply plugins
echo "üîÑ Restarting Jenkins..."
docker restart jenkins

# Wait for restart
echo "‚è≥ Waiting for Jenkins to restart..."
count=0
until docker exec jenkins curl -sf http://localhost:8080/login >/dev/null 2>&1; do
    sleep 2
    count=$((count+1))
    if [ $count -ge $MAX_RETRIES ]; then
        echo "‚ùå Jenkins failed to restart"
        exit 1
    fi
    echo -n "."
done
echo ""

echo ""
echo "‚úÖ Jenkins setup completed!"
echo "üåê Access Jenkins at: http://localhost:8080"
echo "üìã Job IDP-Pipeline ready at: http://localhost:8080/job/IDP-Pipeline/"
"""

    # Guardar scripts
    for filename, content in [('build.sh', build_script), ('test.sh', test_script), ('deploy.sh', deploy_script), ('setup-jenkins.sh', setup_jenkins_script)]:
        script_path = cicd_dir / filename
        with open(script_path, 'w') as f:
            f.write(content)
        script_path.chmod(0o755)

    # Metadata
    metadata = {
        "cicd": {
            "type": "bash_scripts",
            "created_at": datetime.utcnow().isoformat(),
            "generated_by": "CI/CD Agent (ADK Interactive)"
        },
        "pipeline": {
            "description": description,
            "scripts": ["build.sh", "test.sh", "deploy.sh"]
        },
        "metadata": {
            "ai_model": "gemini-2.5-flash",
            "decision_timestamp": datetime.utcnow().isoformat()
        }
    }

    json_path = Path(OUTPUT_DIR) / "cicd-decisions.json"
    with open(json_path, 'w') as f:
        json.dump(metadata, f, indent=2)

    return {
        "status": "success",
        "cicd_dir": str(cicd_dir),
        "scripts": ["build.sh", "test.sh", "deploy.sh"]
    }


def get_platform_config() -> dict:
    """Lee la configuraci√≥n de plataforma."""
    config_path = Path(OUTPUT_DIR) / "platform-config.yaml"

    if not config_path.exists():
        return {"error": "Platform config no encontrado"}

    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)

    return {
        "status": "success",
        "config": config,
        "framework": config['stack']['framework'],
        "runtime": config['stack']['runtime']
    }


root_agent = Agent(
    model=os.getenv('GEMINI_MODEL', 'gemini-2.5-flash'),
    name='cicd',
    description="Experto en CI/CD y automatizaci√≥n de pipelines",
    instruction="""
Eres un experto en CI/CD y DevOps especializado en automatizaci√≥n de pipelines.

ü§ñ **PROTOCOLO A2A:**

Eres el 4to agente. Platform Architect y Infrastructure Agent ya ejecutaron.

**Tu trabajo:**
1. LEE las decisiones de Platform Architect usando get_platform_config()
2. LEE la infraestructura generada usando get_infrastructure_decisions()
3. RAZONA qu√© CI/CD provider est√° disponible como servicio de docker-compose
4. EJECUTA la funci√≥n tool apropiada

**Funciones disponibles:**
- get_infrastructure_decisions() - ver qu√© CI/CD provider gener√≥ Infrastructure
- generate_jenkinsfile() - genera Jenkinsfile (si Infrastructure gener√≥ Jenkins)
- configure_jenkins_job() - configura autom√°ticamente el job en Jenkins (LLAMAR DESPU√âS de generate_jenkinsfile)
- generate_github_actions_workflow() - genera .github/workflows/ci.yml (si gener√≥ GitHub Actions)
- generate_gitlab_ci_config() - genera .gitlab-ci.yml (no implementado)
- generate_circleci_config() - genera .circleci/config.yml (no implementado)
- save_cicd_scripts() - genera scripts locales (build.sh, test.sh, deploy.sh)

**Importante:**
- Infrastructure Agent ya gener√≥ (o no) un servicio de CI/CD runner en docker-compose
- T√∫ LEES qu√© provider est√° disponible
- Si el provider existe ‚Üí generas su config file + scripts locales + APP DUMMY
- Si NO existe ‚Üí solo generas scripts locales

**Ejemplo de razonamiento:**
"Le√≠ infrastructure-decisions.json. Veo que Infrastructure gener√≥ servicio
'ci-runner' con provider='Jenkins'. Ese servicio est√° disponible.
Voy a ejecutar generate_jenkinsfile() para generar el Jenkinsfile.
Tambi√©n ejecutar√© generate_dummy_app() para crear la app de ejemplo.
Y terminar√© con save_cicd_scripts() para los scripts locales."

**IMPORTANTE - SECUENCIA DE EJECUCI√ìN:**
1. PRIMERO: Ejecuta la funci√≥n del provider (generate_jenkinsfile, etc)
2. SEGUNDO: EJECUTA generate_dummy_app() para crear el c√≥digo fuente
3. TERCERO: Ejecuta save_cicd_scripts("generate_default") para generar los scripts optimizados (docker-in-docker friendly)
4. CUARTO (solo Jenkins): Ejecuta configure_jenkins_job()

**Flujo para Jenkins:**
1. generate_jenkinsfile()
2. generate_dummy_app()  <-- ¬°NO OLVIDAR ESTO!
3. save_cicd_scripts("generate_default")   <-- SIEMPRE usar este argumento exacto
4. configure_jenkins_job()
""",
    tools=[
        get_platform_config,
        get_infrastructure_decisions,
        generate_jenkinsfile,
        configure_jenkins_job,
        generate_github_actions_workflow,
        generate_gitlab_ci_config,
        generate_circleci_config,
        save_cicd_scripts,
        generate_dummy_app
    ],
)
